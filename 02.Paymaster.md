# 2. Paymaster

## Overview

## Table of Contents

- [General Paymaster](#general-paymaster)
- [Considerations when integrating the Paymaster contract to your project](#considerations-when-integrating-the-paymaster-contract-to-your-project)
- [NFT Gated Access](#nft-gated-access)
- [Daily Limit Control](#daily-limit-control)
- [AllowList](#allowlist)
- [ERC20 Token Payment](#erc20-token-payment)
- [Frontend Integration](#frontend-integration)
- [Demo](#demo)
- [Conclusion](#conclusion)
- [Next Steps](#next-steps)
- [References](#references)

## General Paymaster

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {
    IPaymaster,
    ExecutionResult,
    PAYMASTER_VALIDATION_SUCCESS_MAGIC
} from "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IPaymaster.sol";
import {IPaymasterFlow} from "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IPaymasterFlow.sol";
import {
    TransactionHelper,
    Transaction
} from "@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol";
import {BOOTLOADER_FORMAL_ADDRESS} from "@matterlabs/zksync-contracts/l2/system-contracts/Constants.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/// @author Matter Labs
/// @notice This contract does not include any validations other than using the paymaster general flow.
contract GeneralPaymaster is IPaymaster, Ownable {
    modifier onlyBootloader() {
        require(msg.sender == BOOTLOADER_FORMAL_ADDRESS, "Only bootloader can call this method");
        // Continue execution if called from the bootloader.
        _;
    }

    constructor() Ownable(msg.sender) {}

    function validateAndPayForPaymasterTransaction(bytes32, bytes32, Transaction calldata _transaction)
        external
        payable
        onlyBootloader
        returns (bytes4 magic, bytes memory context)
    {
        // By default we consider the transaction as accepted.
        magic = PAYMASTER_VALIDATION_SUCCESS_MAGIC;
        require(_transaction.paymasterInput.length >= 4, "The standard paymaster input must be at least 4 bytes long");

        bytes4 paymasterInputSelector = bytes4(_transaction.paymasterInput[0:4]);
        if (paymasterInputSelector == IPaymasterFlow.general.selector) {
            // Note, that while the minimal amount of ETH needed is tx.gasPrice * tx.gasLimit,
            // neither paymaster nor account are allowed to access this context variable.
            uint256 requiredETH = _transaction.gasLimit * _transaction.maxFeePerGas;

            // The bootloader never returns any data, so it can safely be ignored here.
            (bool success,) = payable(BOOTLOADER_FORMAL_ADDRESS).call{value: requiredETH}("");
            require(success, "Failed to transfer tx fee to the Bootloader. Paymaster balance might not be enough.");
        } else {
            revert("Unsupported paymaster flow in paymasterParams.");
        }
    }

    function postTransaction(
        bytes calldata _context,
        Transaction calldata _transaction,
        bytes32,
        bytes32,
        ExecutionResult _txResult,
        uint256 _maxRefundedGas
    ) external payable override onlyBootloader {}

    function withdraw(address payable _to) external onlyOwner {
        uint256 balance = address(this).balance;
        (bool success,) = _to.call{value: balance}("");
        require(success, "Failed to withdraw funds from paymaster.");
    }

    receive() external payable {}
}
```

- Modify the `GeneralPaymaster` contract

```solidity
// contracts/contracts/paymaster/LibroPaymaster.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {
    IPaymaster,
    ExecutionResult,
    PAYMASTER_VALIDATION_SUCCESS_MAGIC
} from "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IPaymaster.sol";
import {IPaymasterFlow} from "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IPaymasterFlow.sol";
import {
    TransactionHelper,
    Transaction
} from "@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol";
import {BOOTLOADER_FORMAL_ADDRESS} from "@matterlabs/zksync-contracts/l2/system-contracts/Constants.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract LibroPaymaster is IPaymaster, Ownable {
    // ====== Custom Errors ======
    error LibroPaymaster__OnlyBootloaderCanCallThisMethod();
    error LibroPaymaster__PaymasterInputShouldBeAtLeast4BytesLong();
    error LibroPaymaster__FailedToTransferTxFeeToBootloader();
    error LibroPaymaster__UnsupportedPaymasterFlowInPaymasterParams();
    error LibroPaymaster__FailedToWithdrawFundsFromPaymaster();

    // ====== Modifiers ======
    modifier onlyBootloader() {
        if (msg.sender != BOOTLOADER_FORMAL_ADDRESS) {
            revert LibroPaymaster__OnlyBootloaderCanCallThisMethod();
        }
        // Continue execution if called from the bootloader.
        _;
    }

    // ====== Constructor ======
    constructor() Ownable(msg.sender) {}

    /**
     *
     * @notice Function used to validate and pay for the zkSync transaction. It can be called only by the bootloader.
     * @param _transaction Structure used to represent zkSync transaction.
     * @return magic  PAYMASTER_VALIDATION_SUCCESS_MAGIC on validation success.
     * @return context Empty bytes array, as it is not used in the current implementation.
     */
    function validateAndPayForPaymasterTransaction(bytes32, bytes32, Transaction calldata _transaction)
        external
        payable
        onlyBootloader
        returns (bytes4 magic, bytes memory context)
    {
        // By default we consider the transaction as accepted.
        magic = PAYMASTER_VALIDATION_SUCCESS_MAGIC;
        if (_transaction.paymasterInput.length < 4) {
            revert LibroPaymaster__PaymasterInputShouldBeAtLeast4BytesLong();
        }

        bytes4 paymasterInputSelector = bytes4(_transaction.paymasterInput[0:4]);
        if (paymasterInputSelector == IPaymasterFlow.general.selector) {
            // Note, that while the minimal amount of ETH needed is tx.gasPrice * tx.gasLimit,
            // neither paymaster nor account are allowed to access this context variable.
            uint256 requiredETH = _transaction.gasLimit * _transaction.maxFeePerGas;

            // The bootloader never returns any data, so it can safely be ignored here.
            (bool success,) = payable(BOOTLOADER_FORMAL_ADDRESS).call{value: requiredETH}("");
            if (!success) {
                revert LibroPaymaster__FailedToTransferTxFeeToBootloader();
            }
        } else {
            revert LibroPaymaster__UnsupportedPaymasterFlowInPaymasterParams();
        }
    }

    /**
     *
     * @notice Function used to execute extra logic after the zkSync transaction is executed. It can be called only by the bootloader.
     * @param _context Empty bytes array, as it is not used in the current implementation.
     * @param _transaction Structure used to represent zkSync transaction.
     * @param _txResult Enum used to represent the result of the transaction execution.
     * @param _maxRefundedGas Maximum amount of gas that can be refunded to the paymaster.
     */
    function postTransaction(
        bytes calldata _context,
        Transaction calldata _transaction,
        bytes32,
        bytes32,
        ExecutionResult _txResult,
        uint256 _maxRefundedGas
    ) external payable override onlyBootloader {}

    function withdraw(address payable _to) external onlyOwner {
        uint256 balance = address(this).balance;
        (bool success,) = _to.call{value: balance}("");
        if (!success) {
            revert LibroPaymaster__FailedToWithdrawFundsFromPaymaster();
        }
    }

    receive() external payable {}
}
```

```
import { HardhatUserConfig } from "hardhat/config";

import "@matterlabs/hardhat-zksync";

const config: HardhatUserConfig = {
  defaultNetwork: "zkSyncSepoliaTestnet",
  networks: {
    ...,
  },
  zksolc: {
    version: "latest",
    settings: {
      // Make sure 'isSystem' is set to 'true' to compile the system contracts.
      isSystem: true,
    },
  },
  solidity: {
    version: "0.8.24",
  },
};

export default config;
```

```bash
$ npx hardhat compile

...
Successfully compiled 1 Solidity file
Done in 9.19s.
```

## Considerations when integrating the Paymaster contract to your project

## NFT Gated Access

```solidity
// contracts/contracts/paymaster/NftGated.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";

abstract contract NftGated {
    error NftGated__SenderDoesNotOwnNft();

    IERC721 public immutable nft;

    /**
     * @notice Checks if the sender owns an NFT.
     * @param account Address of the account to check for NFT ownership.
     */
    function _requireNftOwner(address account) internal view {
        if (nft.balanceOf(account) == 0) {
            revert NftGated__SenderDoesNotOwnNft();
        }
    }
}
```

```solidity
import {NftGated, IERC721} from "./NftGated.sol";
```

```solidity
contract LibroPaymaster is IPaymaster, NftGated, Ownable {
    ...
}
```

```solidity
constructor(address _nft) Ownable(msg.sender) {
    nft = IERC721(_nft);
}
```

```solidity
function validateAndPayForPaymasterTransaction(bytes32, bytes32, Transaction calldata _transaction)
    external
    payable
    onlyBootloader
    returns (bytes4 magic, bytes memory context)
{
    // By default we consider the transaction as accepted.
    magic = PAYMASTER_VALIDATION_SUCCESS_MAGIC;
    if (_transaction.paymasterInput.length < 4) {
        revert LibroPaymaster__PaymasterInputShouldBeAtLeast4BytesLong();
    }

    // Check if the user owns the NFT.
    address userAddress = address(uint160(_transaction.from));

    _requireNftOwner(userAddress);

    bytes4 paymasterInputSelector = bytes4(_transaction.paymasterInput[0:4]);

    ...
}
```

```solidity
// contracts/contracts/token/interfaces/IERC6454.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC6454 { /* is IERC165 */
    /**
     * @notice Used to check whether the given token is transferable or not.
     * @dev If this function returns `false`, the transfer of the token MUST revert execution.
     * @dev If the tokenId does not exist, this method MUST revert execution, unless the token is being checked for
     *  minting.
     * @dev The `from` parameter MAY be used to also validate the approval of the token for transfer, but anyone
     *  interacting with this function SHOULD NOT rely on it as it is not mandated by the proposal.
     * @param tokenId ID of the token being checked
     * @param from Address from which the token is being transferred
     * @param to Address to which the token is being transferred
     * @return Boolean value indicating whether the given token is transferable
     */
    function isTransferable(uint256 tokenId, address from, address to) external view returns (bool);
}
```

```solidity
// contracts/contracts/token/LibroNFT.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.24;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {IERC6454} from "./interfaces/IERC6454.sol";

/**
 * @title LibroNFT
 * @dev Basic ERC721 token.
 */
contract LibroNFT is ERC721, IERC6454 {
    error LibroNFT__Soulbound();

    uint256 private _tokenId;
    string private _tokenURI;

    constructor(string memory uri) ERC721("LibroNFT", "LIBRO") {
        _tokenURI = uri;
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        _requireOwned(tokenId);

        return _tokenURI;
    }

    /**
     * @dev Mints a new token to the sender.
     */
    function mint() external {
        uint256 tokenId = _tokenId++;
        _safeMint(msg.sender, tokenId);
    }

    /**
     * @dev Burns the token.
     */
    function burn(uint256 tokenId) external {
        _requireOwned(tokenId);
        _burn(tokenId);
    }

    /**
     * @notice Used to check whether the given token is transferable or not.
     * @dev IERC-6454 implementation.
     * @param tokenId token id to check
     * @param from address from which the token is being transferred
     * @param to address to which the token is being transferred
     * @return Boolean value indicating whether the given token is transferable
     */
    function isTransferable(uint256 tokenId, address from, address to) public view returns (bool) {
        /*
            Only allow:
            - Minting tokens to Non-Zero address
            - Burning tokens by sending to Zero address
         */

        if (from == address(0x0) && to == address(0x0)) {
            return false;
        }

        if (from == address(0x0) || to == address(0x0)) {
            return true;
        }

        _requireOwned(tokenId);

        // Disallow transfer of tokens.
        return false;
    }

    /**
     * @dev Overriding ERC721 _update function to add transfer restrictions.
     */
    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {
        address from = _ownerOf(tokenId);

        // Only allow minting and burning of tokens.
        if (isTransferable(tokenId, from, to)) {
            return super._update(to, tokenId, auth);
        }

        // Revert by default.
        revert LibroNFT__Soulbound();
    }

    /**
     * @dev Overriding IERC-165 supportsInterface function to add ERC-6454 support.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC6454).interfaceId || super.supportsInterface(interfaceId);
    }
}
```

```bash
$ yarn hardhat compile
...
Successfully compiled 4 Solidity files
Done in 12.02s.
```

## Daily Limit Control

## AllowList

## ERC20 Token Payment

## Frontend Integration

## Demo

## Conclusion

## Next Steps

## References
